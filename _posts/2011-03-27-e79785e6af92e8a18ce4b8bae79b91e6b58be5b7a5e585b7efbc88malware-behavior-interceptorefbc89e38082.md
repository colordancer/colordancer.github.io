---
id: 1057
title: '病毒行为监测工具（Malware Behavior Interceptor）。'
date: '2011-03-27T22:18:05+08:00'
author: colordancer
layout: post
guid: 'http://www.colordancer.net/blog/?p=1057'
permalink: /2011/03/27/%e7%97%85%e6%af%92%e8%a1%8c%e4%b8%ba%e7%9b%91%e6%b5%8b%e5%b7%a5%e5%85%b7%ef%bc%88malware-behavior-interceptor%ef%bc%89%e3%80%82/
views:
    - '2630'
categories:
    - 开发设计
---

这是去年刚来北京时做的一个工具，用来自动判断某文件是否属于病毒，完成的版本只能用做演示，后来工作忙起来了，就没时间再回去修改。现在看看，好像快烂在电脑里了。还不如分享出来，希望给他人有所帮助。

[![](/images/wp-content/uploads/2011/03/捕获-600x451.jpg "捕获")](/images/wp-content/uploads/2011/03/捕获-600x451.jpg)

实现的功能：  
1\. 利用微软的Detours实现API inline hook  
2\. 实现简单的沙箱功能  
a. 文件重定向  
b. 注册表重定向  
c. 进程、线程控制  
3\. 被控进程与控制进程数据实时交互  
4\. 进程行为判断规则功能，自动识别程序是否恶意  
  
目前功能的原型大部分出来了，但是个别handle的重定向处理得不够完善，所以在加载大程序时会出现崩溃的情况。而且目前只处理了少部分的常见API，其他API的处理流程应该大同小异。

在做的时候遇到些问题：  
1\. 因为注入的方式是dll远程注入，所以控制进程与被控制进程的通信是个问题。跨进程通信目前有很多方法：共享文件、socket等等。由于这个工具的通信更依赖于内存，依赖于一定的结构体，并且是只读的数据，所以最后决定使用消息传递：WM\_COPYDATA。WM\_COPYDATA消息的主要目的是允许在进程间传递只读数据。这个函数的原型及其要用到的结构如下:

SendMessage(hwnd,WM\_COPYDATA,wParam,lParam);

其中WM\_COPYDATA对应的十六进制数为0x004A ，wParam设置为包含数据的窗口的句柄，lParam指向一个COPYDATASTRUCT的结构：  
\[c\]  
typedef struct tagCOPYDATASTRUCT{  
DWORD dwData;//用户定义数据  
DWORD cbData;//数据大小  
PVOID lpData;//指向数据的指针  
}COPYDATASTRUCT;  
\[/c\]  
接收方通过DefWndProc事件修改WM\_COPYDATA消息的处理 或者通过窗口的CDialog::OnCopyData(pWnd, pCopyDataStruct)事件来响应。

2\. 利用Detours hook主要是因为方便安全。而且因为要挂钩其他进程，但是该进程是通过本进程启动的，所以流程应该是：  
a. 启动该进程，并suspend  
b. 注入  
c. 继续该进程  
所以，如果要自己写hook，必须用createprocess方法来注入dll。（搜索关键字”CreateProcess 注入“）。而Detours对该功能有封装函数，即DetourCreateProcessWithDll。  
\[c\]  
BOOL DetourCreateProcessWithDll(  
LPCTSTR lpApplicationName,  
LPTSTR lpCommandLine,  
LPSECURITY\_ATTRIBUTES lpProcessAttributes,  
LPSECURITY\_ATTRIBUTES lpThreadAttributes,  
BOOL bInheritHandles,  
DWORD dwCreationFlags,  
LPVOID lpEnvironment,  
LPCTSTR lpCurrentDirectory,  
LPSTARTUPINFOW lpStartupInfo,  
LPPROCESS\_INFORMATION lpProcessInformation,  
LPCSTR lpDetouredDllPath,  
LPCSTR lpDllName,  
PDETOUR\_CREATE\_PROCESS\_ROUTINEW pfCreateProcessW  
);

\[/c\]

3\. 重定向。对于文件的重定向，简单的做法是在磁盘上开辟另一个缓存，对文件的修改操作直接重定向到该缓冲区的拷贝的同一个文件；而对注册表的修改，将其重定向到内存里的一个数据结构，因为对注册表的修改的目的不是注册表本身，而是注册表中存储的值，所以将注册表中的值转移到内存中即可；对于进程重定向，即判断是否挂钩修改的进程；对于线程重定向，如果是CreateRemoteThread，则判断是否挂钩注入的进程。

4\. 病毒行为判断基于规则+打分机制。比如，修改注册表某键值=10分，删除windows/system32目录下的某文件=20分，当分数累计到一定分数时，获得对该进程的一个判断结果。这样做只是实现了一个原型，如果真正应用，其实还有很多地方需要细化。